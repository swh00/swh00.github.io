---
layout: post
title: "[Algorithm] 모듈 없이 올림(Ceiling) 구현하기"
date: 2025-12-30 19:30:00 +0900
categories: [개발, 간단한 팁]
tags: [math, trick, optimization]
---

알고리즘 문제를 풀다 보면 **나눗셈의 결과를 올림(Ceiling)** 처리해야 할 때가 많습니다.
`math` 모듈을 import 해서 `math.ceil()`을 사용할 수 있지만, 라이브러리 호출 없이 **정수 연산(Integer Arithmetic)**만으로 훨씬 간결하고 빠르게 처리하는 방법이 있습니다.

## 1. 문제 상황
파이썬의 정수 나눗셈 연산자 `//`는 기본적으로 **내림(Floor)** 처리를 합니다. 즉, 소수점 이하를 버립니다.

```python
print(10 // 3)  # 결과: 3 (3.333... -> 3)
```

하지만 문제에서 요구하는 것이 **"나머지가 있으면 무조건 몫을 1 올려라"** (예: 페이지 수 계산, 타일 개수 계산)인 경우, 내림 처리를 해야하는 귀찮은 상황이 발생합니다.

## 2. 모듈 해결법 (math 모듈)
파이썬에서는 모듈을 이용해 해결하는 방법으로 `math` 모듈을 사용하는 것이 있습니다.

```python
import math

H = 10
N = 3
result = math.ceil(H / N) # 4
```
하지만 코딩 테스트에서 매번 `import math`를 하거나, 나눗셈 후 실수(float)로 변환되었다가 다시 정수로 돌아오는 과정은 번거롭기도 하고 미세한 성능 차이를 만들 수도 있습니다.

---

## 3. 간단한 방식: (A + B - 1) // B
하지만 라이브러리 없이 올림을 구현하는 방법은 다음과 같이 쉽습니다.

**`X`를 `Y`로 나누어 올림**을 하고 싶다면:

```python
# 올림 공식
result = (X + Y - 1) // Y
```

### 원리 이해하기
이 식의 원리는 **"나누어지는 수에 (나누는 수 - 1)을 미리 더해버리는 것"**입니다.

1.  **나누어 떨어질 때 (나머지 0):**
    * 예: `12 // 4 = 3`
    * 공식: `(12 + 4 - 1) // 4` = `15 // 4` = `3`
    * 나누는 수보다 1 작은 값을 더했으므로, 몫이 바뀌지 않는다.

2.  **나머지가 있을 때 (나머지 > 0):**
    * 예: `13 // 4 = 3` (올림하면 4가 되어야 함)
    * 공식: `(13 + 4 - 1) // 4` = `16 // 4` = `4`
    * 나머지가 1이라도 있으면, 거기에 `B-1`이 더해지면서 분자가 나누는 수 `B`만큼 커지게 된다. 따라서 몫이 1 증가한다.

## 4. 결론
* **속도:** 함수 호출 오버헤드가 없고, 부동 소수점 연산이 아닌 순수 정수 연산이라 빠르다.
* **편의성:** `import`가 필요 없다.
* **활용:** 페이징 처리, 그리드 계산 등.

> **C/C++/Java의 차이점:**
> C나 Java에서 정수 나눗셈(`/`)은 기본적으로 **0 방향으로 버림(Truncation)**을 한다. (`-10 / 3` 결과가 `-3`)
> 반면 파이썬의 `//`는 **무조건 내림(Floor)**을 한다. (`-10 // 3` 결과가 `-4`)

앞으로 올림이 필요할 땐 `math.ceil` 대신 `(A + B - 1) // B`를 기억하면 편하게 해결할 수 있겠습니다.
